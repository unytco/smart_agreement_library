/// Subject: Holo's Proof of Service provided by a Happ Provider
/// 
/// Users:
/// - Happ Provider (Spender): 
///      This is the agent that has asked hosts to provide service, This is the agent that will create an agreement
///      from this code template.
/// - Log Harvester (Invoicing Gateway)
///      This is the central node that is an automated agent that will get the invoices and create the invoice in place of each host
/// - Hosts (Receiver)
//       This is the agent that gets paid for the service they provided 
///
/// Inputs:
/// - spender_unyt_allocation: This will be auto generated by the pre-processor, is the base amount allocated by the spending agent
/// - log_harvester_unyt_allocation: This will be auto generated by the pre-processor, is the service units allocated by the invoicing gateway
/// - work_proofs: a vec of work_proofs containing receiver agent and logs
///   - host_pub_key: the pubkey of the host that is being paid
///   - logs: the logs that were provided by the host
/// - price-sheet: Fixed input - the price sheet to be used for the calculation
///
/// Summary:
/// 1. The happ provider will set up and agreement for this code template, having them set up as the happ_provider role and the executor role
///
/// 2. Now in the log collection there is a table to map a host->DNA->agreement_hash, this hash is what the log-harvester will park its invoice on
/// The log harvester will create an invoice link but calculating the total amount of gossip, and storage that its going to invoice for
/// And it will provide the log that will be used as work_proof
/// 
/// work_proof validation:
/// ...
/// 
/// 3. happ-provider: will get notified that a new invoice was created. 
///    - the happ-provider and either do the math of how much needs to be paid based on the price sheet
///    - or execute a dry run of the agreement and check the error to know how much needs to be paid
///  
/// Execution logic:
/// - collect all the service units that need to be paid for by summing all the invoice links
/// - use the price sheet to calculate what the base unit amount should be for payment
/// -collect all the based unit that was paid and see if it matches the expected amount
/// - if it matches, allocate the amount to the right host based on the invoiced links 
///      Document: amount returned to spender or the carry forward 
/// - else, return an error with the message of how much is expected 
///
let todo = inputs.work_proof;

// check type of unyt_allocation
let final_unyt_allocation = [];
let spender_unyt_allocation = consumed_inputs.spender_allocations;

let invoice_gateway_unyt_allocation = [];
for (value, count) in consumed_inputs.invoice_gateway_allocations_invoice {
  let invoice_amount = value.data.amount;
  
  // Find the index of the spend that will cover the invoice amount
  let spender_index = spender_unyt_allocation.index_of(|a| parse_float(a.data.amount["0"]) >= parse_float(invoice_amount["0"]));

  if spender_index >= 0 {
    let spender_amount = spender_unyt_allocation[spender_index];
    
    final_unyt_allocation.push(#{
      "receiver": consumed_inputs.receiver[count].data,
      "amounts": invoice_amount,
      "source": spender_amount.data.source
    });
    
    // Calculate the remaining amount
    let remaining_amount = sub_units(spender_amount.data.amount, invoice_amount);
    
    // Update the element in place with the remaining amount
    spender_unyt_allocation[spender_index].data.amount = remaining_amount;
    
  } else {
    throw "Invoice not paid";
  }
}

return #{
  "output": #{
    "unyt_allocation": final_unyt_allocation
  }
};
