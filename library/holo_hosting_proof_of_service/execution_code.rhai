/// Subject: Holo's Proof of Service provided by a Happ Provider
/// 
/// Users:
/// - Happ Provider (Spender): 
///      This is the agent that has asked hosts to provide service, This is the agent that will create an agreement
///      from this code template.
/// - Log Harvester (Invoicing Gateway)
///      This is the central node that is an automated agent that will get the invoices and create the invoice in place of each host
/// - Hosts (Receiver)
//       This is the agent that gets paid for the service they provided 
///
/// Inputs:
/// - spender_unyt_allocation: This will be auto generated by the pre-processor, is the base amount allocated by the spending agent
/// - log_harvester_unyt_allocation: This will be auto generated by the pre-processor, is the service units allocated by the invoicing gateway
/// - work_proofs: a vec of work_proofs containing receiver agent and logs
///   - host_pub_key: the pubkey of the host that is being paid
///   - logs: the logs that were provided by the host
/// - price-sheet: Fixed input - the price sheet to be used for the calculation
///
/// Summary:
/// 1. The happ provider will set up and agreement for this code template, having them set up as the happ_provider role and the executor role
///
/// 2. Now in the log collection there is a table to map a host->DNA->agreement_hash, this hash is what the log-harvester will park its invoice on
/// The log harvester will create an invoice link but calculating the total amount of gossip, and storage that its going to invoice for
/// And it will provide the log that will be used as work_proof
/// 
/// work_proof validation:
/// ...
/// 
/// 3. happ-provider: will get notified that a new invoice was created. 
///    - the happ-provider and either do the math of how much needs to be paid based on the price sheet
///    - or execute a dry run of the agreement and check the error to know how much needs to be paid
///  
/// Execution logic:
/// - collect all the service units that need to be paid for by summing all the invoice links
/// - use the price sheet to calculate what the base unit amount should be for payment
/// -collect all the based unit that was paid and see if it matches the expected amount
/// - if it matches, allocate the amount to the right host based on the invoiced links 
///      Document: amount returned to spender or the carry forward 
/// - else, return an error with the message of how much is expected 
///

// Service units invoiced for
let HST = "1"; // holochain storage
let HGSP = "2"; // holochain gossip

// get price sheet data blob
let price_sheet_data_blob = get_data_blob(inputs.price_sheet_data_blob_hash.data);
let storage_price = price_sheet_data_blob.base_per_st;
let gossip_price = price_sheet_data_blob.base_per_gsp;

// compare the log_harvester_spender_allocations with the invoice_payload and if they match 
// calculate the price expected, based on the service units logged

// check type of unyt_allocation
let final_unyt_allocation = [];
let total_payment_expected = 0;
let total_gossip_units_invoiced = 0;
let total_storage_units_invoiced = 0;
let hp_alloc = consumed_inputs.happ_provider_spender_allocations;

let able_to_pay = true;
// the aggregate invoice payloads
for (value, count) in consumed_inputs.invoice_payloads {
  // parse the individual arrays of invoice payloads
  for (payload, i) in value.data {
    
    let logs = payload.logs;
    // iterate over each log
    let total_gossip_units = 0;
    let total_storage_units = 0;
    for (log, i) in logs {
      total_gossip_units = total_gossip_units + parse_float(log["g"]);
      total_storage_units = total_storage_units + parse_float(log["s"]);
    }
    
    let gossip_amount = total_gossip_units * gossip_price;
    let storage_amount = total_storage_units * storage_price;
    
    let exp_amt = storage_amount + gossip_amount;

    total_payment_expected = total_payment_expected + exp_amt;
    total_gossip_units_invoiced = total_gossip_units_invoiced + total_gossip_units;
    total_storage_units_invoiced = total_storage_units_invoiced + total_storage_units;

    // if the execution is able to allocate the amount, then we can continue
    if able_to_pay {
        // Find the index of the spend that will cover the invoice amount
        let hp_index = hp_alloc.index_of(|a| parse_float(a.data.amount["0"]) >= exp_amt);

        if hp_index >= 0 {
          let hp_amount_used = hp_alloc[hp_index];
          
          // todo: this can be optimized by summing all the amounts for the specific host into one allocation
          let invoice_amount = #{
            "0": exp_amt.to_string()
          };
          final_unyt_allocation.push(#{
            "receiver": payload.host_pub_key,
            "amounts": invoice_amount,
            "sources": [hp_amount_used.data.source]
          });
          
          // Calculate the remaining amount
          let remaining_amount = sub_units(hp_amount_used.data.amount, invoice_amount);
          
          // Update the element in place with the remaining amount
          hp_alloc[hp_index].data.amount = remaining_amount;
          
        } else {
          // find out what the total invoiced amount is or how much is missing
          able_to_pay = false;
          continue;
          // throw "All invoices should be paid";
        }
    } else {
      // else we only continue to calculate the total expected amount
      continue;
    }
  }
}

if able_to_pay {

  // attach the total gossip and storage units invoiced to the unyt allocation
  final_unyt_allocation.push(#{
    "receiver": executor_pub_key,
    "amounts": #{ 
      "1": total_gossip_units_invoiced.to_string(), 
      "2": total_storage_units_invoiced.to_string() 
    },
    "sources": consumed_inputs.invoice_payloads.map(|p| p.link_hash)
  });

  // calculate the remaining amount in the hp_alloc and return it as unyt allocation
  // to the happ provider
  // Future: we will implement carry over so that we dont need to spend again
  let remaining_hp_alloc = 0;
  let remaining_sources = [];
  for (hp_alloc, i) in hp_alloc {
    if parse_float(hp_alloc.data.amount["0"]) > 0 {
      remaining_hp_alloc = remaining_hp_alloc + parse_float(hp_alloc.data.amount["0"]);
      remaining_sources.push(hp_alloc.data.source);
    }
  }

  if remaining_hp_alloc > 0 {
    final_unyt_allocation.push(#{
      "receiver": executor_pub_key,
      "amounts": #{ 
        "0": remaining_hp_alloc.to_string() 
      },
      "sources": remaining_sources
    });
  }

  return #{
    "output": #{
      "unyt_allocation": final_unyt_allocation
    }
  };
} else {
  throw "For execution to succeed, a payment of " + total_payment_expected.to_string() + " ZF must be sent to this agreement to settle outstanding invoices.";
}